// -*- C++ -*-
// $Id: Header.h,v 1.3 2002-10-14 02:06:56 edwards Exp $

/*! @file
 * @brief Bulk of QDP operators produced by PETE
 */

#ifndef QDPOPS_H
#define QDPOPS_H

///////////////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE WAS GENERATED AUTOMATICALLY!
// YOU SHOULD MODIFY THE INPUT FILES INSTEAD OF CHANGING THIS FILE DIRECTLY!
//
// THE FOLLOWING INPUT FILES WERE USED TO MAKE THIS FILE:
//
// MakeOperators
// QDPOps.in
// QDPClasses.in
//
///////////////////////////////////////////////////////////////////////////////


struct FnAdjoint
{
  PETE_EMPTY_CONSTRUCTORS(FnAdjoint)
  template<class T>
  inline typename UnaryReturn<T, FnAdjoint >::Type_t
  operator()(const T &a) const
  {
    return (adj(a));
  }
};

struct FnConjugate
{
  PETE_EMPTY_CONSTRUCTORS(FnConjugate)
  template<class T>
  inline typename UnaryReturn<T, FnConjugate >::Type_t
  operator()(const T &a) const
  {
    return (conj(a));
  }
};

struct FnTranspose
{
  PETE_EMPTY_CONSTRUCTORS(FnTranspose)
  template<class T>
  inline typename UnaryReturn<T, FnTranspose >::Type_t
  operator()(const T &a) const
  {
    return (transpose(a));
  }
};

struct FnTransposeColor
{
  PETE_EMPTY_CONSTRUCTORS(FnTransposeColor)
  template<class T>
  inline typename UnaryReturn<T, FnTransposeColor >::Type_t
  operator()(const T &a) const
  {
    return (transposeColor(a));
  }
};

struct FnTransposeSpin
{
  PETE_EMPTY_CONSTRUCTORS(FnTransposeSpin)
  template<class T>
  inline typename UnaryReturn<T, FnTransposeSpin >::Type_t
  operator()(const T &a) const
  {
    return (transposeSpin(a));
  }
};

struct FnTrace
{
  PETE_EMPTY_CONSTRUCTORS(FnTrace)
  template<class T>
  inline typename UnaryReturn<T, FnTrace >::Type_t
  operator()(const T &a) const
  {
    return (trace(a));
  }
};

struct FnRealTrace
{
  PETE_EMPTY_CONSTRUCTORS(FnRealTrace)
  template<class T>
  inline typename UnaryReturn<T, FnRealTrace >::Type_t
  operator()(const T &a) const
  {
    return (realTrace(a));
  }
};

struct FnImagTrace
{
  PETE_EMPTY_CONSTRUCTORS(FnImagTrace)
  template<class T>
  inline typename UnaryReturn<T, FnImagTrace >::Type_t
  operator()(const T &a) const
  {
    return (imagTrace(a));
  }
};

struct FnTraceColor
{
  PETE_EMPTY_CONSTRUCTORS(FnTraceColor)
  template<class T>
  inline typename UnaryReturn<T, FnTraceColor >::Type_t
  operator()(const T &a) const
  {
    return (traceColor(a));
  }
};

struct FnTraceSpin
{
  PETE_EMPTY_CONSTRUCTORS(FnTraceSpin)
  template<class T>
  inline typename UnaryReturn<T, FnTraceSpin >::Type_t
  operator()(const T &a) const
  {
    return (traceSpin(a));
  }
};

struct FnReal
{
  PETE_EMPTY_CONSTRUCTORS(FnReal)
  template<class T>
  inline typename UnaryReturn<T, FnReal >::Type_t
  operator()(const T &a) const
  {
    return (real(a));
  }
};

struct FnImag
{
  PETE_EMPTY_CONSTRUCTORS(FnImag)
  template<class T>
  inline typename UnaryReturn<T, FnImag >::Type_t
  operator()(const T &a) const
  {
    return (imag(a));
  }
};

struct FnLocalNorm2
{
  PETE_EMPTY_CONSTRUCTORS(FnLocalNorm2)
  template<class T>
  inline typename UnaryReturn<T, FnLocalNorm2 >::Type_t
  operator()(const T &a) const
  {
    return (localNorm2(a));
  }
};

struct FnTimesI
{
  PETE_EMPTY_CONSTRUCTORS(FnTimesI)
  template<class T>
  inline typename UnaryReturn<T, FnTimesI >::Type_t
  operator()(const T &a) const
  {
    return (timesI(a));
  }
};

struct FnTimesMinusI
{
  PETE_EMPTY_CONSTRUCTORS(FnTimesMinusI)
  template<class T>
  inline typename UnaryReturn<T, FnTimesMinusI >::Type_t
  operator()(const T &a) const
  {
    return (timesMinusI(a));
  }
};

struct FnSeedToFloat
{
  PETE_EMPTY_CONSTRUCTORS(FnSeedToFloat)
  template<class T>
  inline typename UnaryReturn<T, FnSeedToFloat >::Type_t
  operator()(const T &a) const
  {
    return (seedToFloat(a));
  }
};

struct FnSpinProjectDir0Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir0Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir0Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir0Plus(a));
  }
};

struct FnSpinProjectDir1Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir1Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir1Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir1Plus(a));
  }
};

struct FnSpinProjectDir2Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir2Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir2Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir2Plus(a));
  }
};

struct FnSpinProjectDir3Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir3Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir3Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir3Plus(a));
  }
};

struct FnSpinProjectDir0Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir0Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir0Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir0Minus(a));
  }
};

struct FnSpinProjectDir1Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir1Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir1Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir1Minus(a));
  }
};

struct FnSpinProjectDir2Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir2Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir2Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir2Minus(a));
  }
};

struct FnSpinProjectDir3Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinProjectDir3Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinProjectDir3Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinProjectDir3Minus(a));
  }
};

struct FnSpinReconstructDir0Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir0Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir0Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir0Plus(a));
  }
};

struct FnSpinReconstructDir1Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir1Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir1Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir1Plus(a));
  }
};

struct FnSpinReconstructDir2Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir2Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir2Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir2Plus(a));
  }
};

struct FnSpinReconstructDir3Plus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir3Plus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir3Plus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir3Plus(a));
  }
};

struct FnSpinReconstructDir0Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir0Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir0Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir0Minus(a));
  }
};

struct FnSpinReconstructDir1Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir1Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir1Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir1Minus(a));
  }
};

struct FnSpinReconstructDir2Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir2Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir2Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir2Minus(a));
  }
};

struct FnSpinReconstructDir3Minus
{
  PETE_EMPTY_CONSTRUCTORS(FnSpinReconstructDir3Minus)
  template<class T>
  inline typename UnaryReturn<T, FnSpinReconstructDir3Minus >::Type_t
  operator()(const T &a) const
  {
    return (spinReconstructDir3Minus(a));
  }
};

struct FnChiralProjectPlus
{
  PETE_EMPTY_CONSTRUCTORS(FnChiralProjectPlus)
  template<class T>
  inline typename UnaryReturn<T, FnChiralProjectPlus >::Type_t
  operator()(const T &a) const
  {
    return (chiralProjectPlus(a));
  }
};

struct FnChiralProjectMinus
{
  PETE_EMPTY_CONSTRUCTORS(FnChiralProjectMinus)
  template<class T>
  inline typename UnaryReturn<T, FnChiralProjectMinus >::Type_t
  operator()(const T &a) const
  {
    return (chiralProjectMinus(a));
  }
};

struct FnCmplx
{
  PETE_EMPTY_CONSTRUCTORS(FnCmplx)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnCmplx >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (cmplx(a,b));
  }
};

struct FnOuterProduct
{
  PETE_EMPTY_CONSTRUCTORS(FnOuterProduct)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnOuterProduct >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (outerProduct(a,b));
  }
};

struct FnColorVectorContract
{
  PETE_EMPTY_CONSTRUCTORS(FnColorVectorContract)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnColorVectorContract >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (colorVectorContract(a,b));
  }
};

struct FnColorCrossProduct
{
  PETE_EMPTY_CONSTRUCTORS(FnColorCrossProduct)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnColorCrossProduct >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (colorCrossProduct(a,b));
  }
};

struct FnLocalInnerProduct
{
  PETE_EMPTY_CONSTRUCTORS(FnLocalInnerProduct)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnLocalInnerProduct >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (localInnerProduct(a,b));
  }
};

struct FnLocalInnerProductReal
{
  PETE_EMPTY_CONSTRUCTORS(FnLocalInnerProductReal)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnLocalInnerProductReal >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (localInnerProductReal(a,b));
  }
};

struct FnLocalColorInnerProduct
{
  PETE_EMPTY_CONSTRUCTORS(FnLocalColorInnerProduct)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnLocalColorInnerProduct >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (localColorInnerProduct(a,b));
  }
};

struct FnQuarkContract13
{
  PETE_EMPTY_CONSTRUCTORS(FnQuarkContract13)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnQuarkContract13 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (quarkContract13(a,b));
  }
};

struct FnQuarkContract14
{
  PETE_EMPTY_CONSTRUCTORS(FnQuarkContract14)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnQuarkContract14 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (quarkContract14(a,b));
  }
};

struct FnQuarkContract23
{
  PETE_EMPTY_CONSTRUCTORS(FnQuarkContract23)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnQuarkContract23 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (quarkContract23(a,b));
  }
};

struct FnQuarkContract24
{
  PETE_EMPTY_CONSTRUCTORS(FnQuarkContract24)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnQuarkContract24 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (quarkContract24(a,b));
  }
};

struct FnQuarkContract12
{
  PETE_EMPTY_CONSTRUCTORS(FnQuarkContract12)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnQuarkContract12 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (quarkContract12(a,b));
  }
};

struct FnQuarkContract34
{
  PETE_EMPTY_CONSTRUCTORS(FnQuarkContract34)
  template<class T1, class T2>
  inline typename BinaryReturn<T1, T2, FnQuarkContract34 >::Type_t
  operator()(const T1 &a, const T2 &b) const
  {
    return (quarkContract34(a,b));
  }
};

struct FnColorContract
{
  PETE_EMPTY_CONSTRUCTORS(FnColorContract)
  template<class T1, class T2, class T3>
  inline typename TrinaryReturn<T1, T2, T3, FnColorContract >
  ::Type_t
  operator()(const T1 &a, const T2 &b, const T3 &c) const
  {
    return (colorContract(a,b,c));
  }
};

//! Hermitian adjoint
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnAdjoint,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnAdjoint >::Type_t >::Expression_t
adj(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnAdjoint,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnAdjoint >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Complex conjugate
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnConjugate,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnConjugate >::Type_t >::Expression_t
conj(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnConjugate,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnConjugate >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Transpose
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTranspose,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTranspose >::Type_t >::Expression_t
transpose(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTranspose,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTranspose >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Transpose in Color Space Only
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTransposeColor,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTransposeColor >::Type_t >::Expression_t
transposeColor(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTransposeColor,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTransposeColor >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Transpose in Spin Space Only
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTransposeSpin,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTransposeSpin >::Type_t >::Expression_t
transposeSpin(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTransposeSpin,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTransposeSpin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Trace on all fiber indices
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTrace,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTrace >::Type_t >::Expression_t
trace(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTrace,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTrace >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Real part of the trace on all fiber indices
/*! @ingroup group1
  @sa real()
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnRealTrace,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnRealTrace >::Type_t >::Expression_t
realTrace(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnRealTrace,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnRealTrace >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Imag part of the trace on all fiber indices
/*! @ingroup group1
  @sa imag()
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnImagTrace,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnImagTrace >::Type_t >::Expression_t
imagTrace(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnImagTrace,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnImagTrace >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Trace on only color indices
/*! @ingroup group1
  @sa trace(), TraceColor()
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTraceColor,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTraceColor >::Type_t >::Expression_t
traceColor(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTraceColor,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTraceColor >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Trace on only spin indices
/*! @ingroup group1
  @sa trace()
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTraceSpin,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTraceSpin >::Type_t >::Expression_t
traceSpin(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTraceSpin,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTraceSpin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Real part
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnReal,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnReal >::Type_t >::Expression_t
real(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnReal,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnReal >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Imag part
/*! @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnImag,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnImag >::Type_t >::Expression_t
imag(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnImag,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnImag >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! InnerProduct on only fiber indices
/*! L2 norm only fiber indices
  @sa adj(), trace()
  @return (trace(adj(l)*l)
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnLocalNorm2,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnLocalNorm2 >::Type_t >::Expression_t
localNorm2(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnLocalNorm2,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnLocalNorm2 >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Multiply by imaginary i
/*! @sa operator*()
  @return (i * a)
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTimesI,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTimesI >::Type_t >::Expression_t
timesI(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTimesI,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTimesI >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Multiply by minus imaginary i
/*! @sa operator*()
  @return (-i * a)
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTimesMinusI,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTimesMinusI >::Type_t >::Expression_t
timesMinusI(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTimesMinusI,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTimesMinusI >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Convert a seed (big int) to a float
/*! Used only by random number generator
  @return a float in [0,1] from a seed (big int)
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSeedToFloat,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSeedToFloat >::Type_t >::Expression_t
seedToFloat(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSeedToFloat,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSeedToFloat >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 0
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 + gamma[0])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir0Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir0Plus >::Type_t >::Expression_t
spinProjectDir0Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir0Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir0Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 1
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 + gamma[1])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir1Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir1Plus >::Type_t >::Expression_t
spinProjectDir1Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir1Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir1Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 2
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 + gamma[2])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir2Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir2Plus >::Type_t >::Expression_t
spinProjectDir2Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir2Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir2Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 3
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 + gamma[3])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir3Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir3Plus >::Type_t >::Expression_t
spinProjectDir3Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir3Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir3Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 0
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 - gamma[0])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir0Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir0Minus >::Type_t >::Expression_t
spinProjectDir0Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir0Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir0Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 1
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 - gamma[1])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir1Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir1Minus >::Type_t >::Expression_t
spinProjectDir1Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir1Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir1Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 2
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 - gamma[2])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir2Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir2Minus >::Type_t >::Expression_t
spinProjectDir2Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir2Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir2Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin projection in direction 3
/*! Returns half-spin vector from a full spin vector source
  @param l  full spin vector
  @return (1 - gamma[3])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir3Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir3Minus >::Type_t >::Expression_t
spinProjectDir3Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir3Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir3Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 3
/*! Returns full spin vector from a half spin vector source
  @param l  half-spin vector
  @return (1 + gamma[0])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir0Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir0Plus >::Type_t >::Expression_t
spinReconstructDir0Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir0Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir0Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 1
/*! Returns full-spin vector from a half-spin vector source
  @param l  half-spin vector
  @return (1 + gamma[1])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir1Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir1Plus >::Type_t >::Expression_t
spinReconstructDir1Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir1Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir1Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 2
/*! Returns full-spin vector from a half-spin vector source
  @param l  half-spin vector
  @return (1 + gamma[2])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir2Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir2Plus >::Type_t >::Expression_t
spinReconstructDir2Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir2Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir2Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 3
/*! Returns full-spin vector from a half-spin vector source
  @param l  half-spin vector
  @return (1 + gamma[3])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir3Plus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir3Plus >::Type_t >::Expression_t
spinReconstructDir3Plus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir3Plus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir3Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 0
/*! Returns full-spin vector from a half-spin vector source
  @param l  half-spin vector
  @return (1 - gamma[0])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir0Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir0Minus >::Type_t >::Expression_t
spinReconstructDir0Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir0Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir0Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 1
/*! Returns full-spin vector from a half-spin vector source
  @param l  half-spin vector
  @return (1 - gamma[1])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir1Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir1Minus >::Type_t >::Expression_t
spinReconstructDir1Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir1Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir1Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 2
/*! Returns full-spin vector from a half-spin vector source
  @param l  half-spin vector
  @return (1 - gamma[2])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir2Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir2Minus >::Type_t >::Expression_t
spinReconstructDir2Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir2Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir2Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Spin reconstruct in direction 3
/*! Returns full-spin vector from a half-spin vector source
  @param l  half-spin vector
  @return (1 - gamma[3])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir3Minus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir3Minus >::Type_t >::Expression_t
spinReconstructDir3Minus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir3Minus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir3Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Apply P_+ = 0.5*(1+gamma_5)
/*! Returns full-spin vector 
  @param l  full-spin vector
  @return 0.5*(1 + gamma[5])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnChiralProjectPlus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnChiralProjectPlus >::Type_t >::Expression_t
chiralProjectPlus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnChiralProjectPlus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnChiralProjectPlus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Apply P_ = -0.5*(1-gamma_5)
/*! Returns full-spin vector 
  @param l  full-spin vector
  @return 0.5*(1 - gamma[5])*l
  @ingroup group1
  @relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnChiralProjectMinus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnChiralProjectMinus >::Type_t >::Expression_t
chiralProjectMinus(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnChiralProjectMinus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnChiralProjectMinus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Arc cos
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnArcCos,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnArcCos >::Type_t >::Expression_t
acos(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnArcCos,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnArcCos >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Arc sin
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnArcSin,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnArcSin >::Type_t >::Expression_t
asin(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnArcSin,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnArcSin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Arc tangent
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnArcTan,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnArcTan >::Type_t >::Expression_t
atan(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnArcTan,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnArcTan >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Floating point ceiling of source
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnCeil,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnCeil >::Type_t >::Expression_t
ceil(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnCeil,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnCeil >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Cosine
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnCos,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnCos >::Type_t >::Expression_t
cos(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnCos,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnCos >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Hyperbolic cosine
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnHypCos,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnHypCos >::Type_t >::Expression_t
cosh(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnHypCos,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnHypCos >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Exponential
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnExp,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnExp >::Type_t >::Expression_t
exp(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnExp,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnExp >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Floating point absolute value
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnFabs,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnFabs >::Type_t >::Expression_t
fabs(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnFabs,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnFabs >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! floating point floor of source
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnFloor,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnFloor >::Type_t >::Expression_t
floor(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnFloor,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnFloor >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Log
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnLog,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnLog >::Type_t >::Expression_t
log(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnLog,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnLog >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Log base 10
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnLog10,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnLog10 >::Type_t >::Expression_t
log10(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnLog10,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnLog10 >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Sine
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSin,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSin >::Type_t >::Expression_t
sin(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSin,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Hyperbolic sine
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnHypSin,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnHypSin >::Type_t >::Expression_t
sinh(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnHypSin,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnHypSin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Square root
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSqrt,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSqrt >::Type_t >::Expression_t
sqrt(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnSqrt,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSqrt >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Tangent
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTan,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTan >::Type_t >::Expression_t
tan(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnTan,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTan >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Hyperbolic tangent
/*! @ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnHypTan,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnHypTan >::Type_t >::Expression_t
tanh(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<FnHypTan,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnHypTan >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Unary minus
/*! 
@return -a
@ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpUnaryMinus >::Type_t >::Expression_t
operator-(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpUnaryMinus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Unary plus
/*!
@return +a
@ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpUnaryPlus >::Type_t >::Expression_t
operator+(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpUnaryPlus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Bitwise not
/*!
@return (~a)
@ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpBitwiseNot >::Type_t >::Expression_t
operator~(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpBitwiseNot >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Identity operator
/*! Constructs expression form of a source
@return (a)
@ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpIdentity,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpIdentity >::Type_t >::Expression_t
PETE_identity(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<OpIdentity,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpIdentity >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Boolean not operator
/*! 
@return (!a)
@ingroup group1
@relates QDPType */
template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpNot,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpNot >::Type_t >::Expression_t
operator!(const QDPType<T1,C1> & l)
{
  typedef UnaryNode<OpNot,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpNot >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l)));
}

//! Build a complex from two reals
/*! Returns a complex value
  @param l  real (a reality scalar)
  @param r  real (a reality scalar)
  @return (l + i*r)
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnCmplx>::Type_t >::Expression_t
cmplx(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Construct the outer product of two vectors
/*! 
  Constructs the outer product of two vectors within the same vector space
  @param l  vector
  @param r  vector
  @return \f$(l_i * r_j^*)_{ij}\f$
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Sum over colorvector indices
/*! 
  Contract two colorvectors with no conjugation
  @param l  vector
  @param r  vector
  @return \f$\sum_i l_i * r_i\f$
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Cross product of two Nc=3 color vectors
/*! 
  Antisymmetric combination of two Nc=3 color vectors
  @param l  vector
  @param r  vector
  @return \f$target^{i} = \sum_{jk}\epsilon^{i j k}*source1^{j}*source2^{k}\f$
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! InnerProduct on only fiber indices
/*! L2 norm only fiber indices
  @sa adj(), trace()
  @return (trace(adj(l)*r)
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Real part of innerproduct on only fiber indices
/*! L2 norm only fiber indices
  @sa adj(), trace(), real()
  @return (real(trace(adj(l)*r))
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! InnerProduct on only color fiber indices
/*! L2 norm only color fiber indices
  @sa adj(), trace()
  @return (traceColor(adj(l)*r)
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Contraction for quark propagators
/*! 
   epsilon contract 2 quark propagators and return a quark propagator.
   This is used for diquark constructions. Eventually, it could handle larger
   Nc. 
   The numbers represent which spin index to sum over.
   
   The sources and targets must all be propagators but not
   necessarily of the same lattice type. Effectively, one can use
   this to construct an anti-quark from a di-quark contraction. In
   explicit index form, the operation  QuarkContract13 does
   
   \f$target^{k' k}_{\alpha\beta} =
     \epsilon^{i j k}\epsilon^{i' j' k'}* source1^{i i'}_{\rho\alpha}* source2^{j j'}_{\rho\beta}\f$
   
   and is (currently) only appropriate for Nc=3  (or SU(3)).
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Contraction for quark propagators
/*! 
   epsilon contract 2 quark propagators and return a quark propagator.
   This is used for diquark constructions. Eventually, it could handle larger
   Nc. 
   The numbers represent which spin index to sum over.
   
   The sources and targets must all be propagators but not
   necessarily of the same lattice type. Effectively, one can use
   this to construct an anti-quark from a di-quark contraction. In
   explicit index form, the operation  QuarkContract14 does
   
  \f$target^{k' k}_{\alpha\beta} =
    \epsilon^{i j k}\epsilon^{i' j' k'}*source1^{i i'}_{\rho\alpha}*source2^{j j'}_{\beta\rho}\f$

   and is (currently) only appropriate for Nc=3  (or SU(3)).
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Contraction for quark propagators
/*! 
   epsilon contract 2 quark propagators and return a quark propagator.
   This is used for diquark constructions. Eventually, it could handle larger
   Nc. 
   The numbers represent which spin index to sum over.
   
   The sources and targets must all be propagators but not
   necessarily of the same lattice type. Effectively, one can use
   this to construct an anti-quark from a di-quark contraction. In
   explicit index form, the operation  QuarkContract23 does
   
  \f$target^{k' k}_{\alpha\beta} =
    \epsilon^{i j k}\epsilon^{i' j' k'}*source1^{i i'}_{\alpha\rho}*source2^{j j'}_{\rho\beta}\f$

   and is (currently) only appropriate for Nc=3  (or SU(3)).
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Contraction for quark propagators
/*! 
   epsilon contract 2 quark propagators and return a quark propagator.
   This is used for diquark constructions. Eventually, it could handle larger
   Nc. 
   The numbers represent which spin index to sum over.
   
   The sources and targets must all be propagators but not
   necessarily of the same lattice type. Effectively, one can use
   this to construct an anti-quark from a di-quark contraction. In
   explicit index form, the operation  QuarkContract24 does
   
  \f$target^{k' k}_{\alpha\beta} =
    \epsilon^{i j k}\epsilon^{i' j' k'}*source1^{i i'}_{\rho\alpha}*source2^{j j'}_{\beta\rho}\f$

   and is (currently) only appropriate for Nc=3  (or SU(3)).
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Contraction for quark propagators
/*! 
   epsilon contract 2 quark propagators and return a quark propagator.
   This is used for diquark constructions. Eventually, it could handle larger
   Nc. 
   The numbers represent which spin index to sum over.
   
   The sources and targets must all be propagators but not
   necessarily of the same lattice type. Effectively, one can use
   this to construct an anti-quark from a di-quark contraction. In
   explicit index form, the operation  QuarkContract12 does
   
  \f$target^{k' k}_{\alpha\beta} =
    \epsilon^{i j k}\epsilon^{i' j' k'}*source1^{i i'}_{\rho\rho}*source2^{j j'}_{\alpha\beta}\f$

   and is (currently) only appropriate for Nc=3  (or SU(3)).
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Contraction for quark propagators
/*! 
   epsilon contract 2 quark propagators and return a quark propagator.
   This is used for diquark constructions. Eventually, it could handle larger
   Nc. 
   The numbers represent which spin index to sum over.
   
   The sources and targets must all be propagators but not
   necessarily of the same lattice type. Effectively, one can use
   this to construct an anti-quark from a di-quark contraction. In
   explicit index form, the operation  QuarkContract34 does
   
  \f$target^{k' k}_{\alpha\beta} =
    \epsilon^{i j k}\epsilon^{i' j' k'}*source1^{i i'}_{\alpha\beta}*source2^{j j'}_{\rho\rho}\f$

   and is (currently) only appropriate for Nc=3  (or SU(3)).
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Binary addition
/*! 
@return (a+b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAdd>::Type_t >::Expression_t
operator+(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Binary subtract
/*! 
@return (a-b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpSubtract>::Type_t >::Expression_t
operator-(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Binary multiply
/*!
 @return (a * b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMultiply>::Type_t >::Expression_t
operator*(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Binary division
/*!
 @return (a / b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpDivide>::Type_t >::Expression_t
operator/(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Binary mod
/*! Also call mod(a,b)
@return (a % b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMod>::Type_t >::Expression_t
operator%(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Bitwise and
/*!
 @return (a & b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Bitwise or
/*! 
@return (a | b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t >::Expression_t
operator|(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Bitwise exclusive or
/*! 
@return (a ^ b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t >::Expression_t
operator^(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Load exponent
/*! Calculates the value a times 2 to the power b.
Based on the C-math lib function.
@return ldexp(a,b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLdexp>::Type_t >::Expression_t
ldexp(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! a to the power b
/*! Based on the C-math lib function.
@return pow(a,b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnPow>::Type_t >::Expression_t
pow(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Floating point remainder
/*! Computes a modulo b.
Based on the C-math lib function.
@return fmod(a,b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnFmod>::Type_t >::Expression_t
fmod(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Arctan of a/b
/*! Produces correct angles near +-pi/2 (or a near 0).
Based on the C-math lib function.
@return atan2(a,b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnArcTan2>::Type_t >::Expression_t
atan2(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Less than
/*! Boolean result 
@return (a < b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLT>::Type_t >::Expression_t
operator<(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Less than equal
/*! Boolean result 
@return (a <= b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLE>::Type_t >::Expression_t
operator<=(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Great than
/*! Boolean result 
@return (a > b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGT>::Type_t >::Expression_t
operator>(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Great than equal
/*! Boolean result 
@return (a >= b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGE>::Type_t >::Expression_t
operator>=(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Equality
/*! Boolean result 
@return (a == b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpEQ>::Type_t >::Expression_t
operator==(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Not equal
/*! Boolean result 
@return (a != b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpNE>::Type_t >::Expression_t
operator!=(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Logical and
/*! Boolean result 
@return (a && b)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAnd>::Type_t >::Expression_t
operator&&(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Logical or
/*! Boolean result 
@return (a | b)
@ingroup group1
@relates QDPType */

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpOr>::Type_t >::Expression_t
operator||(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Left shift
/*! Not cyclic
@return (a left shifted by b bits)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLeftShift>::Type_t >::Expression_t
operator<<(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

//! Right shift
/*! Not cyclic
@return (a right shifted by b bits)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpRightShift>::Type_t >::Expression_t
operator>>(const QDPType<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnCmplx>::Type_t >::Expression_t
cmplx(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAdd>::Type_t >::Expression_t
operator+(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpSubtract>::Type_t >::Expression_t
operator-(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMultiply>::Type_t >::Expression_t
operator*(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpDivide>::Type_t >::Expression_t
operator/(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMod>::Type_t >::Expression_t
operator%(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t >::Expression_t
operator|(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t >::Expression_t
operator^(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLdexp>::Type_t >::Expression_t
ldexp(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnPow>::Type_t >::Expression_t
pow(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnFmod>::Type_t >::Expression_t
fmod(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnArcTan2>::Type_t >::Expression_t
atan2(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLT>::Type_t >::Expression_t
operator<(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLE>::Type_t >::Expression_t
operator<=(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGT>::Type_t >::Expression_t
operator>(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGE>::Type_t >::Expression_t
operator>=(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpEQ>::Type_t >::Expression_t
operator==(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpNE>::Type_t >::Expression_t
operator!=(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAnd>::Type_t >::Expression_t
operator&&(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpOr>::Type_t >::Expression_t
operator||(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLeftShift>::Type_t >::Expression_t
operator<<(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpRightShift>::Type_t >::Expression_t
operator>>(const QDPType<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnCmplx>::Type_t >::Expression_t
cmplx(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAdd>::Type_t >::Expression_t
operator+(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpSubtract>::Type_t >::Expression_t
operator-(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMultiply>::Type_t >::Expression_t
operator*(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpDivide>::Type_t >::Expression_t
operator/(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMod>::Type_t >::Expression_t
operator%(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t >::Expression_t
operator|(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t >::Expression_t
operator^(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLdexp>::Type_t >::Expression_t
ldexp(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnPow>::Type_t >::Expression_t
pow(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnFmod>::Type_t >::Expression_t
fmod(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnArcTan2>::Type_t >::Expression_t
atan2(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLT>::Type_t >::Expression_t
operator<(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLE>::Type_t >::Expression_t
operator<=(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGT>::Type_t >::Expression_t
operator>(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGE>::Type_t >::Expression_t
operator>=(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpEQ>::Type_t >::Expression_t
operator==(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpNE>::Type_t >::Expression_t
operator!=(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAnd>::Type_t >::Expression_t
operator&&(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpOr>::Type_t >::Expression_t
operator||(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLeftShift>::Type_t >::Expression_t
operator<<(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpRightShift>::Type_t >::Expression_t
operator>>(const QDPExpr<T1,C1> & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnCmplx>::Type_t >::Expression_t
cmplx(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAdd>::Type_t >::Expression_t
operator+(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpSubtract>::Type_t >::Expression_t
operator-(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMultiply>::Type_t >::Expression_t
operator*(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpDivide>::Type_t >::Expression_t
operator/(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMod>::Type_t >::Expression_t
operator%(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseOr>::Type_t >::Expression_t
operator|(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseXor>::Type_t >::Expression_t
operator^(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLdexp>::Type_t >::Expression_t
ldexp(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnPow>::Type_t >::Expression_t
pow(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnFmod>::Type_t >::Expression_t
fmod(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnArcTan2>::Type_t >::Expression_t
atan2(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLT>::Type_t >::Expression_t
operator<(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLE>::Type_t >::Expression_t
operator<=(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGT>::Type_t >::Expression_t
operator>(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGE>::Type_t >::Expression_t
operator>=(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpEQ>::Type_t >::Expression_t
operator==(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpNE>::Type_t >::Expression_t
operator!=(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAnd>::Type_t >::Expression_t
operator&&(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpOr>::Type_t >::Expression_t
operator||(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLeftShift>::Type_t >::Expression_t
operator<<(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpRightShift>::Type_t >::Expression_t
operator>>(const QDPType<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnCmplx>::Type_t >::Expression_t
cmplx(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAdd>::Type_t >::Expression_t
operator+(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpSubtract>::Type_t >::Expression_t
operator-(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMultiply>::Type_t >::Expression_t
operator*(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpDivide>::Type_t >::Expression_t
operator/(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMod>::Type_t >::Expression_t
operator%(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseOr>::Type_t >::Expression_t
operator|(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseXor>::Type_t >::Expression_t
operator^(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLdexp>::Type_t >::Expression_t
ldexp(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnPow>::Type_t >::Expression_t
pow(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnFmod>::Type_t >::Expression_t
fmod(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnArcTan2>::Type_t >::Expression_t
atan2(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLT>::Type_t >::Expression_t
operator<(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLE>::Type_t >::Expression_t
operator<=(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGT>::Type_t >::Expression_t
operator>(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGE>::Type_t >::Expression_t
operator>=(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpEQ>::Type_t >::Expression_t
operator==(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpNE>::Type_t >::Expression_t
operator!=(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAnd>::Type_t >::Expression_t
operator&&(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpOr>::Type_t >::Expression_t
operator||(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLeftShift>::Type_t >::Expression_t
operator<<(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpRightShift>::Type_t >::Expression_t
operator>>(const typename WordType<C2>::Type_t & l,const QDPType<T2,C2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPType<T2,C2> >::make(r)));
}
#endif // PETE_ALLOW_SCALAR_SHIFT

//! Contraction for color objects
/*! 
   epsilon contract 3 color primitives and return a primitive scalar.
   Eventually, it could handle larger Nc. 
   
   The sources and targets must all be of the same primitive type (a matrix or vector)
   but not necessarily of the same lattice type. In
   explicit index form, the operation  colorContract does
   
   \f$target =
     \epsilon^{i j k}\epsilon^{i' j' k'}* source1^{i i'}* source2^{j j'}*source3^{k k'}\f$
   or
   \f$target =
     \epsilon^{i j k}* source1^{i}* source2^{j}*source3^{k}\f$
   
   and is (currently) only appropriate for Nc=3  (or SU(3)).
  @ingroup group1
  @relates QDPType */
template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPType<T1,C1> & a,const QDPType<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}

//! The C ? operator
/*! The where statement is similar to the C ? operator.
@return (if (a) return b; else return c;)
@ingroup group1
@relates QDPType */
template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPType<T1,C1> & a,const QDPType<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}
#ifndef PETE_EXPRESSION_OPERATORS
#define PETE_EXPRESSION_OPERATORS

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnAdjoint,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnAdjoint >::Type_t >::Expression_t
adj(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnAdjoint,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnAdjoint >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnConjugate,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnConjugate >::Type_t >::Expression_t
conj(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnConjugate,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnConjugate >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTranspose,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTranspose >::Type_t >::Expression_t
transpose(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTranspose,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTranspose >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTransposeColor,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTransposeColor >::Type_t >::Expression_t
transposeColor(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTransposeColor,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTransposeColor >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTransposeSpin,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTransposeSpin >::Type_t >::Expression_t
transposeSpin(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTransposeSpin,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTransposeSpin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTrace,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTrace >::Type_t >::Expression_t
trace(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTrace,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTrace >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnRealTrace,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnRealTrace >::Type_t >::Expression_t
realTrace(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnRealTrace,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnRealTrace >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnImagTrace,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnImagTrace >::Type_t >::Expression_t
imagTrace(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnImagTrace,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnImagTrace >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTraceColor,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTraceColor >::Type_t >::Expression_t
traceColor(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTraceColor,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTraceColor >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTraceSpin,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTraceSpin >::Type_t >::Expression_t
traceSpin(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTraceSpin,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTraceSpin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnReal,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnReal >::Type_t >::Expression_t
real(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnReal,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnReal >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnImag,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnImag >::Type_t >::Expression_t
imag(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnImag,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnImag >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnLocalNorm2,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnLocalNorm2 >::Type_t >::Expression_t
localNorm2(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnLocalNorm2,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnLocalNorm2 >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTimesI,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTimesI >::Type_t >::Expression_t
timesI(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTimesI,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTimesI >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTimesMinusI,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTimesMinusI >::Type_t >::Expression_t
timesMinusI(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTimesMinusI,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTimesMinusI >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSeedToFloat,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSeedToFloat >::Type_t >::Expression_t
seedToFloat(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSeedToFloat,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSeedToFloat >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir0Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir0Plus >::Type_t >::Expression_t
spinProjectDir0Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir0Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir0Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir1Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir1Plus >::Type_t >::Expression_t
spinProjectDir1Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir1Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir1Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir2Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir2Plus >::Type_t >::Expression_t
spinProjectDir2Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir2Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir2Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir3Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir3Plus >::Type_t >::Expression_t
spinProjectDir3Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir3Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir3Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir0Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir0Minus >::Type_t >::Expression_t
spinProjectDir0Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir0Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir0Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir1Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir1Minus >::Type_t >::Expression_t
spinProjectDir1Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir1Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir1Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir2Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir2Minus >::Type_t >::Expression_t
spinProjectDir2Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir2Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir2Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinProjectDir3Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinProjectDir3Minus >::Type_t >::Expression_t
spinProjectDir3Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinProjectDir3Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinProjectDir3Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir0Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir0Plus >::Type_t >::Expression_t
spinReconstructDir0Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir0Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir0Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir1Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir1Plus >::Type_t >::Expression_t
spinReconstructDir1Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir1Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir1Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir2Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir2Plus >::Type_t >::Expression_t
spinReconstructDir2Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir2Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir2Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir3Plus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir3Plus >::Type_t >::Expression_t
spinReconstructDir3Plus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir3Plus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir3Plus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir0Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir0Minus >::Type_t >::Expression_t
spinReconstructDir0Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir0Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir0Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir1Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir1Minus >::Type_t >::Expression_t
spinReconstructDir1Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir1Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir1Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir2Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir2Minus >::Type_t >::Expression_t
spinReconstructDir2Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir2Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir2Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSpinReconstructDir3Minus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSpinReconstructDir3Minus >::Type_t >::Expression_t
spinReconstructDir3Minus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSpinReconstructDir3Minus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSpinReconstructDir3Minus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnChiralProjectPlus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnChiralProjectPlus >::Type_t >::Expression_t
chiralProjectPlus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnChiralProjectPlus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnChiralProjectPlus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnChiralProjectMinus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnChiralProjectMinus >::Type_t >::Expression_t
chiralProjectMinus(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnChiralProjectMinus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnChiralProjectMinus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnArcCos,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnArcCos >::Type_t >::Expression_t
acos(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnArcCos,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnArcCos >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnArcSin,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnArcSin >::Type_t >::Expression_t
asin(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnArcSin,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnArcSin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnArcTan,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnArcTan >::Type_t >::Expression_t
atan(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnArcTan,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnArcTan >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnCeil,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnCeil >::Type_t >::Expression_t
ceil(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnCeil,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnCeil >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnCos,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnCos >::Type_t >::Expression_t
cos(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnCos,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnCos >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnHypCos,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnHypCos >::Type_t >::Expression_t
cosh(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnHypCos,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnHypCos >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnExp,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnExp >::Type_t >::Expression_t
exp(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnExp,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnExp >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnFabs,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnFabs >::Type_t >::Expression_t
fabs(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnFabs,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnFabs >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnFloor,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnFloor >::Type_t >::Expression_t
floor(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnFloor,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnFloor >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnLog,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnLog >::Type_t >::Expression_t
log(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnLog,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnLog >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnLog10,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnLog10 >::Type_t >::Expression_t
log10(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnLog10,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnLog10 >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSin,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSin >::Type_t >::Expression_t
sin(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSin,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnHypSin,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnHypSin >::Type_t >::Expression_t
sinh(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnHypSin,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnHypSin >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnSqrt,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnSqrt >::Type_t >::Expression_t
sqrt(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnSqrt,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnSqrt >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnTan,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnTan >::Type_t >::Expression_t
tan(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnTan,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnTan >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<FnHypTan,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,FnHypTan >::Type_t >::Expression_t
tanh(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<FnHypTan,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,FnHypTan >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpUnaryMinus >::Type_t >::Expression_t
operator-(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpUnaryMinus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpUnaryPlus >::Type_t >::Expression_t
operator+(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpUnaryPlus >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpBitwiseNot >::Type_t >::Expression_t
operator~(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpBitwiseNot >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpIdentity,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpIdentity >::Type_t >::Expression_t
PETE_identity(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<OpIdentity,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpIdentity >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1>
inline typename MakeReturn<UnaryNode<OpNot,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t>,
  typename UnaryReturn<C1,OpNot >::Type_t >::Expression_t
operator!(const QDPExpr<T1,C1> & l)
{
  typedef UnaryNode<OpNot,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t> Tree_t;
  typedef typename UnaryReturn<C1,OpNot >::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnCmplx>::Type_t >::Expression_t
cmplx(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAdd>::Type_t >::Expression_t
operator+(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpSubtract>::Type_t >::Expression_t
operator-(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMultiply>::Type_t >::Expression_t
operator*(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpDivide>::Type_t >::Expression_t
operator/(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpMod>::Type_t >::Expression_t
operator%(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t >::Expression_t
operator|(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t >::Expression_t
operator^(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnLdexp>::Type_t >::Expression_t
ldexp(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnPow>::Type_t >::Expression_t
pow(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnFmod>::Type_t >::Expression_t
fmod(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,FnArcTan2>::Type_t >::Expression_t
atan2(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLT>::Type_t >::Expression_t
operator<(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLE>::Type_t >::Expression_t
operator<=(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGT>::Type_t >::Expression_t
operator>(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpGE>::Type_t >::Expression_t
operator>=(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpEQ>::Type_t >::Expression_t
operator==(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpNE>::Type_t >::Expression_t
operator!=(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpAnd>::Type_t >::Expression_t
operator&&(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpOr>::Type_t >::Expression_t
operator||(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpLeftShift>::Type_t >::Expression_t
operator<<(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<C1,C2,OpRightShift>::Type_t >::Expression_t
operator>>(const QDPExpr<T1,C1> & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,C2,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPExpr<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPExpr<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnCmplx>::Type_t >::Expression_t
cmplx(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAdd>::Type_t >::Expression_t
operator+(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpSubtract>::Type_t >::Expression_t
operator-(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMultiply>::Type_t >::Expression_t
operator*(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpDivide>::Type_t >::Expression_t
operator/(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMod>::Type_t >::Expression_t
operator%(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseOr>::Type_t >::Expression_t
operator|(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseXor>::Type_t >::Expression_t
operator^(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLdexp>::Type_t >::Expression_t
ldexp(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnPow>::Type_t >::Expression_t
pow(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnFmod>::Type_t >::Expression_t
fmod(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnArcTan2>::Type_t >::Expression_t
atan2(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLT>::Type_t >::Expression_t
operator<(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLE>::Type_t >::Expression_t
operator<=(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGT>::Type_t >::Expression_t
operator>(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGE>::Type_t >::Expression_t
operator>=(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpEQ>::Type_t >::Expression_t
operator==(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpNE>::Type_t >::Expression_t
operator!=(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAnd>::Type_t >::Expression_t
operator&&(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpOr>::Type_t >::Expression_t
operator||(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLeftShift>::Type_t >::Expression_t
operator<<(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T1,class C1>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t>,
  typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpRightShift>::Type_t >::Expression_t
operator>>(const QDPExpr<T1,C1> & l,const typename WordType<C1>::Type_t & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<C1,typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(l),
    CreateLeaf<typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C1>::Type_t>::Type_t(r))));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnCmplx,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnCmplx>::Type_t >::Expression_t
cmplx(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnCmplx,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnCmplx>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnOuterProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnOuterProduct>::Type_t >::Expression_t
outerProduct(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnOuterProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnOuterProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorVectorContract,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorVectorContract>::Type_t >::Expression_t
colorVectorContract(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnColorVectorContract,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorVectorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnColorCrossProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorCrossProduct>::Type_t >::Expression_t
colorCrossProduct(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnColorCrossProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnColorCrossProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProduct>::Type_t >::Expression_t
localInnerProduct(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalInnerProductReal,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProductReal>::Type_t >::Expression_t
localInnerProductReal(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalInnerProductReal,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalInnerProductReal>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLocalColorInnerProduct,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalColorInnerProduct>::Type_t >::Expression_t
localColorInnerProduct(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLocalColorInnerProduct,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLocalColorInnerProduct>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract13,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract13>::Type_t >::Expression_t
quarkContract13(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract13,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract13>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract14,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract14>::Type_t >::Expression_t
quarkContract14(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract14,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract14>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract23,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract23>::Type_t >::Expression_t
quarkContract23(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract23,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract23>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract24,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract24>::Type_t >::Expression_t
quarkContract24(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract24,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract24>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract12,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract12>::Type_t >::Expression_t
quarkContract12(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract12,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract12>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnQuarkContract34,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract34>::Type_t >::Expression_t
quarkContract34(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnQuarkContract34,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnQuarkContract34>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAdd>::Type_t >::Expression_t
operator+(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpAdd,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAdd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpSubtract>::Type_t >::Expression_t
operator-(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpSubtract,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpSubtract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMultiply>::Type_t >::Expression_t
operator*(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpMultiply,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMultiply>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpDivide>::Type_t >::Expression_t
operator/(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpDivide,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpDivide>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpMod,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMod>::Type_t >::Expression_t
operator%(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpMod,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpMod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseAnd>::Type_t >::Expression_t
operator&(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseOr>::Type_t >::Expression_t
operator|(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseXor>::Type_t >::Expression_t
operator^(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpBitwiseXor>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLdexp>::Type_t >::Expression_t
ldexp(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnLdexp,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnLdexp>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnPow,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnPow>::Type_t >::Expression_t
pow(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnPow,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnPow>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnFmod>::Type_t >::Expression_t
fmod(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnFmod,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnFmod>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnArcTan2>::Type_t >::Expression_t
atan2(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<FnArcTan2,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,FnArcTan2>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLT,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLT>::Type_t >::Expression_t
operator<(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLT,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLE,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLE>::Type_t >::Expression_t
operator<=(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLE,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGT,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGT>::Type_t >::Expression_t
operator>(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpGT,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGT>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpGE,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGE>::Type_t >::Expression_t
operator>=(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpGE,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpGE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpEQ>::Type_t >::Expression_t
operator==(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpEQ,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpEQ>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpNE,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpNE>::Type_t >::Expression_t
operator!=(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpNE,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpNE>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAnd>::Type_t >::Expression_t
operator&&(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpAnd,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpAnd>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpOr,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpOr>::Type_t >::Expression_t
operator||(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpOr,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpOr>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLeftShift>::Type_t >::Expression_t
operator<<(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpLeftShift,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpLeftShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}

template<class T2,class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
  typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t>,
  typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpRightShift>::Type_t >::Expression_t
operator>>(const typename WordType<C2>::Type_t & l,const QDPExpr<T2,C2> & r)
{
  typedef BinaryNode<OpRightShift,
    typename CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t> Tree_t;
  typedef typename BinaryReturn<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t,C2,OpRightShift>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t >::make(typename SimpleScalar<typename WordType<C2>::Type_t>::Type_t(l)),
    CreateLeaf<QDPExpr<T2,C2> >::make(r)));
}
#endif // PETE_ALLOW_SCALAR_SHIFT

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPExpr<T1,C1> & a,const QDPType<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPExpr<T1,C1> & a,const QDPType<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPType<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPType<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPType<T1,C1> & a,const QDPType<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPType<T1,C1> & a,const QDPType<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPExpr<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPType<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPExpr<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPType<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPType<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPType<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPType<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPType<T1,C1> & a,const QDPExpr<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPType<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPType<T1,C1> >::make(a),
    CreateLeaf<QDPExpr<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnColorContract,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t >::Expression_t
colorContract(const QDPExpr<T1,C1> & a,const QDPType<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnColorContract,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnColorContract>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}

template<class T1,class C1,class T2,class C2,class T3,class C3>
inline typename MakeReturn<TrinaryNode<FnWhere,
  typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
  typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
  typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t>,
  typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t >::Expression_t
where(const QDPExpr<T1,C1> & a,const QDPType<T2,C2> & b,const QDPExpr<T3,C3> & c)
{
  typedef TrinaryNode<FnWhere,
    typename CreateLeaf<QDPExpr<T1,C1> >::Leaf_t,
    typename CreateLeaf<QDPType<T2,C2> >::Leaf_t,
    typename CreateLeaf<QDPExpr<T3,C3> >::Leaf_t> Tree_t;
  typedef typename TrinaryReturn<C1,C2,C3,FnWhere>::Type_t Container_t;
  return MakeReturn<Tree_t,Container_t>::make(Tree_t(
    CreateLeaf<QDPExpr<T1,C1> >::make(a),
    CreateLeaf<QDPType<T2,C2> >::make(b),
    CreateLeaf<QDPExpr<T3,C3> >::make(c)));
}
#endif  // PETE_EXPRESSION_OPERATORS

#endif // QDPOPS_H

